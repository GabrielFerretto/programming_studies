# üêß Linux aula 01 pt-02

## Manipula√ß√£o de arquivos e pastas

<img src="https://media.giphy.com/media/4Zgy9QqzWU8C3ugvCa/giphy.gif" style="width:90px" >

<hr>

### Diret√≥rios
<br>
<img src="../img/diretorios01.png" alt="screenshot de im linux em vmwarer">

<hr>

<strong>/ </strong>  *√â o diret√≥rio-raiz, onde tudo come√ßa. Ele seria equivalente ao <strong>C:\ </strong> do Windows, mas diferente do sistema operacional de Redmond, um sistema <strong> &lowast;
nix </strong> tem sempre uma raiz √∫nica; o Windows cria uma raiz (ou diret√≥rio inicial) para cada volume, sempre identificando com uma letra **(D:\ , E:\ , A:\ e por ai vai)**. Outros volumes do Linux s√£o "pendurados" nesta raiz √∫nica iniciada em **"/"**, e isso traz uma s√©rie de vantagens. O termo exato, na verdade, √© que os "volumes s√£o montados".*
<hr>

**/bin** *√â o diret√≥rio dos bin√°rios no Linux. Os comandos que podem ser executados de alguma forma por quelquer usu√°rio ficam por aqui.*
<hr>

**/boot**  *Armazena os arquivos necess√°rios para realizar o boot do sistema Linux.*
<hr>

**/dev** *"dev" √© uma aprevia√ß√£o da palavra inglesa devices, ou dispositivos; diferentes do Windows que possu√≠mos uma lista de dispositivos como esta: em sistemas <strong> &lowast;
nix </strong>,* 
*os dispositivos viram arquivos fazendo parte do sistema de arquivos. Sendo assim, perif√©ricos, como mouses, impressoras, webcams, e dispositivos embarcados, como HDs e suas parti√ß√µes, tudo vira um arquivo em **/dev***
<hr>

**/etc** *Os arquivos de configura√ß√£o ficam aqui, especialmente os de servi√ßos da m√†quina; quando a configura√ß√£o √© especificada para um determinado usu√°rio, geralmente ficam em pastas ocultas (iniciadas com **"."**, ponto) no diret√≥rio do usu√°rio.*
<hr>

**/home** *Armazena os diret√≥rios de usu√°rios, sendo equivalente ao **C:\Usu√°rios** ou **C:\Users**. Cada usu√°rio possui seu pr√≥prio deret√≥rio (Por exemplo, meu usu√°rio **"bilbo"** possui o **/home/bilbo**).*
<hr>

**lib** *e* **lib64** *Equivalente ao **C:\Windows\System** e **C:\Windows\System32**, s√£o os diret√≥rios onde ficam as bibliotecas de sistema; as bibliotecas em 64bits ficam em **/lib64**, enquanto as 32bits ficam em **/lib**.*
<hr>

**/lost+found** *Diret√≥rio de **"achados e perdidos"** do sistema. Em uma eventual falha no sistema de arquivos, o comando **fsck** deve ser utilizado e, caso ache arquivos ou fragmentos dele que n√£o sabe onde guardar, eles ficam armazenados por aqui.*
<hr>

**/media** *e* **/mnt** *Diret√≥rios de **"montagem"** de volumes, como pendrives CD-ROMs e DVD-ROMs.*
<hr>

**/opt** *Diret√≥rio opcional, pode se utilizado como diret√≥rio alternativo de instala√ß√£o de programas.*
<hr>

**/proc** *Diret√≥rio virtual de informa√ß√µes do sistema; atrav√©s de seus pseudo arquivos, podemos obter informa√ß√µes sobre o processador, uso de mem√≥ria, entre outros.*
<hr>

**/root** *Diret√≥rio pessoal do **super usu√°rio** ou **root**.*
<hr>

**/run** *Os processos em andamento (rodando ou run) geram arquivos **.pid** que ficam armazenados por aqui.*
<hr>

**/sbin** *Os bin√°rios (comandos) espec√≠ficos para uso do **super usu√°rio (root)** ficam armazenados aqui.*
<hr>

**/srv** *Dados de servi√ßos em execu√ß√£o ficam armazenados neste diret√≥rio.*
<hr>

**/sys** *(apenas para kernels 2.6.x ou superiores) armazena os m√≥dulos para equipamentos USB.*
<hr>

**/tmp** *Diret√≥rios de arquivos tempor√°rios, que podem ser gerados por servi√ßos ativos; √© equivalente ao **C:\Windows\Temp**.*
<hr>

**/usr** *√â aqui que os programas s√£o instalados, assim sendo, seria equivalente ao **C:/Arquivos** de programas our **C:\Program Files**.*
<hr>

**/var** *O diret√≥rio **var** armazena informa√ß√µes de tamanhos variados; √© nele, por exemplo, que os arquivos que armazenam dados em um banco de dados ficam.*
<hr>

**/var/log** *Como tamb√©m √© uma informa√ß√£o do tamanho variado, os logs sistema ficam neste subdiret√≥rio.*
<hr>

## Avan√ßando

<img src="https://media.giphy.com/media/S3Pe5NZqgmE8Tl3NI5/giphy-downsized-large.gif" style="width:190px" >
<hr>

### Listar arquivos e diret√≥rios

**ls** *O comando permite exibir informa√ß√µes dos arquivos e subdiret√≥rios de um determinado diret√≥rio.*
```sh
 ls
```
<img src="../img/diretorios02.png">

*Em sua execu√ß√£o simples, exibira apenas o nome dos arquivos e diret√≥rios. Gra√ßas ao padr√£o de cores, podemos diferenciar o que √© arquivo (em verde) do que √© diret√≥rio (em azul). N√£o se baseie, no entanto, em extens√µes de arquivos: diferentes do Windows, elas s√£o completamente dispens√°veis. A extens√£o "txt" nos tr√™s arquivos do exemplo √© apenas para f√°cil indentifica√ß√£o e para seu maior conforto.*

<img src="../img/diretorios03.png">

*O comando **ls** √© geralmente executado com dois par√¢metros muitos √∫teis: **"-l"**, que exibe uma lista longa ou detalhada de informa√ß√µes, e o **"-a"**, que vem de **all**, ou seja, traga **todos** os arquivos e diret√≥rios, mesmo aqueles que s√£o ocultos.*

*Repare que v√°rios outros arquivos e diret√≥rios fizeram parte da listagem agora; seguindo o padr√£o do Unix, arquivos e diret√≥rios ocultos s√£o precedidos por **" . " (ponto)**. Uma grande variedade de informa√ß√¥es √© trazida nesta lista, sendo:*

* **Primeira coluna - Tipo de arquivo e permissionamento:** *Contendo sempre 10 caracteres, os primeiros deles se referem ao tipo de arquivo: um arquivo comum √© representado por um tra√ßo **" - "**, e um diret√≥rio pela letra **" d "**. Voc√™ ver√° ainda as letras **" l "**(aquivo de link), **" b "** e **" c "**(para dispositivos, que transmitem por bloco ou **" b "** e caracter **" c "**). Os nove caracteres restantes devem ser lidos em conjuntos de tr√™s em tr√™s: os tr√™s primeiros s√£o as permiss√¥es do dono do arquivo; os tr√™s do meio permiss√µes do grupo dono do arquivo; e os tr√™s finais, dos demais. As letras **" rwx "** simbolizam leitura (**r** de **read**), (**w** e **escrita**) e (**x** de **execu√ßa√µ**).*

* **Segunda coluna - Quantidade de arquivos:** *Indica a quantidade de arquivos ou diret√≥rios aquele elemento possui. Repare que arquivos possuem sempre o n√∫mero **1**, enquanto diret√≥rios, geralmente, t√™m valores maiores. Na imagem de exemplo, **" .config "** possui 10 arquivos ou subdiret√≥rios dentro dele.*

* **Terceira coluna:** *Exibe o nome do dono do arquivo. Quando o nome n√£o estiver dispon√≠vel, exibe o n√∫mero indentificador do usu√°rio **(uid)**.*

* **Quarta coluna:** *Mostra o nome do grupo dono doarquivo; quando o nome n√£o estiver dispon√≠vel, exibe o n√∫mero indentificador do grupo **(gid)**.*

* **Quinta coluna:** *Exibe o tamanho de **bytes** do aquivo. Ao acrescentar o par√¢metro **" h " (ls -lh)**, o tamanho fica mais leg√≠vel para humanos, sendo apresentado em **megabytes, gigabytes** ou a unidade de medida mais pr√≥xima.*

* **Sexta coluna:** *Mostra a data da √∫ltima modifica√ß√£o no arquivo ou diret√≥rio.*

* **S√©tima coluna:** *O nome do arquivo ou diret√≥rio propriamente dito.*

<br>

*Qunado o diret√≥rio do qual queremos lista n√£o √© mencionado, o comando automaticamente exibe o conte√∫do do diret√≥rio atual ( em meu caso, diret√≥rio de  meu usu√°rio, **/home/bilbo** ). O diret√≥rio desejado pode ser indicado logo depois dos par√¢metros (au ates, por que n√£o ? ):*

<img src="../img/diretorios04.png">
<br>
<hr>

### Mostrar diret√≥rio ou pasta atual

**pwd - ( print work directory ):** 
```sh
 pwd
```
*√â um comando pertinente especialmente em situa√ß√µes em que o prompt de comandos n√£o exibe o diret√≥rio atual.*

<img src="../img/pwd01.png">

*No exemplo em quest√£o, possui um prompt que mostra o diret√≥rio, as de maneira resumida: **" ~ "** ser√° sempre o diret√≥rio-padr√£o ou home do usu√°rio que est√° sendo utilizado.*

<hr>

### Mudar de diret√≥rio ou pasta

**cd** *O comando √© um acr√≥nimo de **change directory** e permite mudar o diret√≥rio atual. O diret√≥rio pode ser mencionado tanto com seu caminho completo ou absoluto **( /home/bilbo )** quanto o caminho relativo, que recebe este nome porque √© relativo ao diret√≥rio que estamos naquele momento. Ou seja **cd bilbo** ( sem a barra antes do bilbo), estando no diret√≥rio **/home**, possibilitar√° acessar o subdiret√≥rio bilbo, **/home/bilbo**.*

```sh
 cd /directory/directory or cd ..
```

<img src="../img/cd.png">

*O comando **cd..** indica o acesso ao diret√≥rio superior ou pai (simbolizado pelo ponto-ponto). A chamada do comando **cd** sem nenhuma informa√ß√£o adicional resulta na troca para o diret√≥rio-padr√£o do usu√°rio, ou seja, equivale ao comando **cd~** ou, no meu caso, **cd /home/bilbo**.*
<hr>

### Criar um diret√≥rio

**mkdir** *O comando mkdir √© uma abrevia√ß√£o da frase inglesa " make a directory ", que significa literalmente " criar um diret√≥rio " .*
```sh
 mkdir Nova\ Pasta

 mkdir Nova_Pasta

 mkdir "Nova pasta"
```
<img src="../img/mkdir01.png">

*Repare que caracteres especiais ( como esoa√ßos " " ou a pr√≥pria barra invertida ) s√£o permitidos, desde que sejam percebidos por uma barra invertida. **Aten√ß√£o** o Linux √© [case-sensitive](https://profound-information.com/why-is-linux-terminal-case-sensitive/), sendo, assim a pasta criada no exemplo foi " Nova Pasta " e n√£o " nova pasta " ( e muito menos NoVa PaStA ).*

*Outra considera√ß√£o √© o fato de que o comando n√£o me congratulou por ter escrito o comando corretamente; n√£o acontece uma mensagem "Diret√≥rio criado com sucesso". O sistema operacional s√≥ apresenta uma mensagem em aso de fracaso, ou seja, n√£o espere um "parab√©ns" por ter acertado o comando ( o Linux provavelmente acredita que " n√£o fiz mais do que minha obriga√ß√£o " ).*

*Um par√¢metro muito √∫til para acompanhar o **mkdir** √© o **" -p "**, especialmente em situa√ß√µes que eu esteja criando subdiret√≥rios.*

<img src="../img/mkdir02.gif">

*Presumindo que eu esteja em meu diret√≥rio de usu√°rio (/home/bilbo), o comando em quest√£o criou uma pasta "Nova Pasta2", um "subdiret√≥rio" dentro desta e um subdiret√≥rio "subsubpasta" dentro de "subpasta". Sem par√¢metro **" -p "**, o comando apresentario um erro, pois ele tentaria localizar a "Nova Pasta2" e n√£o encontraria, ou seja, mkdir Nova\ Paasta2/subpasta/subsubpasta(sem o **" -p "** ) s√≥ criaria o diret√≥rio "subsubpasta", tendo como condi√ß√£o **/home/bilbo/Nova Pasta2/subpasta como um caminho existente e v√°lido**.*
<hr>

### Apagando um arquivo ou diret√≥rio

**rm** *O comando rm √© uma abrevia√ß√£o para o verbo ingl√™s **to remove** e permitir√° que apaguemos um arquivo ou um direr√≥rio. Embora exista o comando **rmdir**, restrito apenas para remo√ß√£o de diret√≥rios, vamos nos ater ao comando que apaga qualquer um dos dois*
```sh
 rm /home/bilbo/package.json
```
*O comando apresentado remove o arquivo de texto " package.json " do diret√≥rio de usu√°rio /home/bilbo. Repare que utilizei o caminho absoluto que, embora seja mais longo, possui menos risco de fazer algo errado. Posso rodar o comando **rm package.json** tamb√©m, desde que eu tenha como diret√≥rio atual **/home/bilbo**; no entanto, se eu estiver em outro diret√≥rio que tamb√©m possui um package.json, a confus√£o est√° criada.*

<img src="../img/rm01.png">

*Posso apagar diret√≥rios, desde que o diret√≥rio em quest√£o esteja completamente vazio (a regra vale para **rmdir** ). Ou seja:*
```sh
 rmdir /home/bilbo/novapasta/subpasta/subsubpasta 
```
*Na Linha de comandos **rmdir /home/bilbo/novapasta/subpasta/subsubpasta**, apenas o diret√≥rio "subsubpasta" seria apagado da exist√™ncia, mantendo "novapasta" e "nuvapasta/subpasta" intactos. Apagar "novapasta" com o comando **rmdir ~ novapasta**(o " ~ " til abrevia /home/bilbo !) n√£o daria certo, pois o diret√≥rio n√£o est√° vazio neste momento, ele tem "subpasta" dentro dele.*

<img src="../img/rmdir01.png">

*Para facilitar onformo que o comando **rm** possui dois par√¢metros usados: **" -r "** significa "recursivo", ou seja, se ao apagar "novapasta" ele tiver resist√™ncia, ele entra aos subdiret√≥rios e os apaga primeiro, e seus subsubdiret√≥rios caso existam, em um verdadeiro efeito cascata. Como se trata de um comando perigoso, o Linux far√° uma pergunta para configurar cada diret√≥rio que eu tentar apagar, esperando um "y" indicando "yes" ou "n" indicando "not" o caso pode ser difente tamb√©m ele pode pedir a senha de usu√°rio **root**.*

<img src="../img/rm02.png">
<br>

```sh
 rm -rf /home/bilbo/novapasta
```
*A  linha de comando **rm -rf /home/bilbo/novapasta** apaga o diret√≥rio "novapasta" e absolutamente tudo que estiver dentro dele, sem d√≥ nem piedade; havia apenas um subdiret√≥rio "subpasta" vazio dentro dele, mas poderiam ter outros 5 milh√µes de arquivos que n√£o faria a menor diferen√ßa (na verdade, faria, mas o comando demoraria um pouquinho) .*

***"Se eu me arrepender, eu restauro da Lixeira", n√£o, n√£o restaura! Lixeira √© para usu√°rios de interface gr√°fica que n√£o sabem o que est√£o fazendo.***

*O comando s√≥ permite que eu apague arquivos e diret√≥rios dos quais eu tenha permiss√£o de faz√™-lo, ou seja, o dano pode ser contido, a n√£o ser que voc√™ seja o superusu√°rio **root**.*
<hr>

### Copiando arquivos e diret√≥rios 

**cp** *O comando √© uma abreviatura do verbo ingl√™s **to copy** e permite copiar arquivos e diret√≥rios, solicitando sempre qual o arquivo copiado e, logo depois, para onde ele ser√° copiado:*
```sh
 cp /home/bilbo/arquivo01.txt  /tmp
```
*No exemplo em linha de comando **cp /home/bilbo/arquivo01.txt /tmp**, o arquivo "arquivo01.txt" foi copiado para outro diret√≥rio, o diret√≥rio de arquivos tempor√°rios **/tmp**. √â importante que voc√™ tenha permiss√£o de escrita no diret√≥rio destino e, neste caso, **/tmp** permite a qualquer usu√°rio de sistema escrever arquivos.*

<img src="../img/cp01.png">
<br>

```sh
 cp /home/bilbo/arquivo01.txt /tmp/novoNome.txt
```
*O segundo exemplo em linha de comando **cp /home/bilbo/arquivo01.txt /tmp/novoNome.txt** faz a mesma opera√ß√£o, mas ao copiar renomeia o novo arquivo para "novoNome.txt". A primeira execu√ß√£o preservou o nome original, ou seja, **/tmp/arquivo01.txt** existe.*

<img src="../img/cp02.png">

**Copiar diret√≥rios inteiros** *√© perfeitamente poss√≠vel, mas precisamos de ajuda de tr√™s par√¢metros: **" -R "** recursividade, ou seja, permite copiar o diret√≥rio e tudo contido dentro dele; o par√¢metro **" -v "** vem da palavra em ingl√™s **verbose** e √© muito comum em comando Linux, neste caso, mostrar√° quais arquivos dentro do diret√≥rio foram copiados; conhe√ßa tamb√©m **" -p "**, que preserva as permiss√µes originais do arquivo copiado:*
```sh
 cp -Rvp /home/bilbo/EXjs/  novapasta/
```
<img src="../img/cp03.png">

*O comando copiou o diret√≥rio EXjs com todo seu conte√∫do (gra√ßas ao "-v", vemos que apenas um arquivo constava, "media01.js") para o diret√≥rio **/novapasta**.*
<hr>

### Movedo osu renomeando arquivos e diret√≥rios

**mv** *O comando mv √© uma abreviatura do verbo ingl√™s **to move** e permite mover arquivos e diret√≥rios e de um ponto a aoutro, solicitando sempre a origem e depois o destino:*
```sh
 mv EXjs/  novapasta/
```
<img src="../img/mv01.png">

*No exemplo de comando **mv /tmp/Imagens /opt**, o diret√≥rio Imagens/ presente no diret√≥rio de arquivos tempor√°rios /tmp foi transferido para o diret√≥rio /opt; para dar certo, o usu√°rio que realiza a opera√ß√£o precisa ter permiss√£o de escrita no diret√≥rio destino. O processo para arquivos √© ind√™ntico.*

*Para renomear o arquivo, o procedimento √© similar; basta informar o nome atual do arquivo e, na sequ√™ncia, o novo nome (fa√ßa o mesmo para diret√≥rios):*
```sh
 mv JS/arquivo01.txt  novapasta/arquivo02.txt
```
<img src="../img/mv02.png">
<hr>

### Exibindo o conte√∫do de um arquivo

**cat** *O comando cat pode ser utilizado para exibir o conte√∫do de um arquivo texto no terminal de comandos e deve ser acompanhado pelo caminho do arquivo.*
```sh
 cat 'nome do arquivo'
```

<img src="../img/cat01.png">
<hr>

### Exibir linhas iniciais de um arquivo

**head** *Como o nome indica, o comando **head** permite exibir o cabe√ßalho do arquivo, ou seja, √© o comando **cat** que mostra apenas as linhas iniciais do arquivo; pode ser muito √∫til para arquivos muito grandes dos quais s√≥ precisa visualizar as primeiras linhas.*
```sh
 head 'nome do arquivo'
```
<img src="../img/head01.png">
<br>

*Podemos tamb√©m utilizar o par√¢metro **" -n "**, que permite determinar o n√∫mero de linhas iniciais que desejo ver do arquivo e est√° sendo usado para exibir as cinco primeiras linhas*
```sh
 head -n 'nome do arquivo'
```
<img src="../img/head02.png">
<hr>

### Exibir linhas finais de um arquivo

**tail** *O comando tail faz o inverso do comando head, e a palavra em ingl√™s significa: "cauda": exibe as √∫ltimas linhas do arquivo desejado. O par√¢metro **" -n "** tamb√©m pode ser usado aqui para definir o n√∫mero de linhas finais que deseja exibir.*
```sh
 tail 'nome do arquivo'

 tail -n 7 'nome do arquivo'
```
*Muito utilizado para a leitura de arquivos de log, que geralmente s√£o muito grandes e, em v√°rios casos, desejamos apenas os √∫ltimos acontecimentos do sistema.*

<img src="../img/tail01.png">

*O comando est√° exibindo as tr√™s ultimas linhas do principal arquivo de log de sistema em, **/var/log/alternatives.log**.*
<hr>

### Exibe o conte√∫do de um arquivo

**less** *O comando pode ser muito √∫til para visualizar aarquivos muito grandes, pois, com ele, podemos navegar no conte√∫do do arquivo com as setas para cima e para baixo, pois a exibi√ß√£o com **cat** √© de dif√≠cil navega√ß√£o*

<img src="../img/less01.gif">

*Utilize as teclas para naveg√ß√£o as setas do teclado para cima e para baixo **[PAGE UP]** e **[PAGE DOWN]** e para sair use **" q "** de (quit) para sair do comando.*
<hr>

### Localizar Arquivos

*√â dif√≠cil localizar um arquivo armazenado em um sistema de arquivos. Com o objetivo de facilitar esta tarefa, podemos usar o comando **locate**.*

*Primeiramente √© preciso instalar o pacote do comando digitando o comando **sudo apt install locate**. Uma vez instalado, √© necess√°rio criar a base para buscas e, para tal, √© necess√°rio rodar o comando **sudo apt update** de tempos em tempos.*

*Para utilizar o comando, digite **locate** e o nome do arquivo que voc√™ deseja buscar:*

<img src="../img/locate01.png">
<hr>

### Localizar termos dentro de arquivos

**grep** *Trata-se de um excelente comando para realizar busca de palavras-chave dentro de arquivos; basta digitar a palavra-chave logo ap√≥s o comando, seguido do local que deseja procurar.*

<img src="../img/grep01.png">

*No exemplo acima estamos buscando a palavra **removed** dentro de **/var/log/pacman.log**.*
<hr>

<br>

## [Linux Parte 03 (click me)](https://github.com/GabrielFerretto/programming_studies/blob/main/Linux-Fundamentos/mod/001-pt03.md "A parte 3 dos estudos ")

